////  Component//  Created by Ketan Anjaria on 2006-11-02.//  Copyright (c) 2006 Metaliq Inc. All rights reserved.//package metaliq.core {	import flash.display.*		import flash.text.*;	import flash.events.*;	import flash.net.*;	import flash.utils.*;			public class Component extends MovieClip {			public var avatar:MovieClip;		public var hitRegion:MovieClip;				/**		 * Creates a new Component component instance.		 * metaliq.core.Component		 */		public function Component() { 			super();			configUI();		}		protected function configUI():void{			stop();			var r:Number = rotation;			rotation = 0;			var w:Number = super.width;			var h:Number = super.height;			super.scaleX = super.scaleY = 1;			setSize(w,h);						rotation = r;			if(avatar != null ) removeChild(avatar);						invalidate();			draw();		}		public function setSize(p_width:Number,p_height:Number):void{			//trace(this+".setSize (" + p_width + ", " + p_height +")")						$width = p_width;			$height = p_height;			invalidate();		}		protected var $height:Number;		override public function set height(p_height:Number):void{			setSize($width,p_height);					}		override public function get height():Number{			return $height;		}		protected var $width:Number;		override public function set width(p_width:Number):void{			setSize(p_width,$height);		}		override public function get width():Number{			return $width;		}		protected var $enabled:Boolean = true;		override public function set enabled(p_enabled:Boolean):void{			$enabled = p_enabled;					}		override public function get enabled():Boolean{			return $enabled;		}		public function draw():void{									dispatchEvent( new Event("draw"))		}		public function invalidate():void{			if (stage != null) {				stage.addEventListener(Event.RENDER,callLaterDispatcher,false,0,true);				stage.invalidate();							} else {				// GDS: switch to constant when it becomes available: Bug Adobe.				addEventListener("addedToStage",callLaterDispatcher,false,0,true);			}		}		private function callLaterDispatcher(event:Event):void {			if (event.type == "addedToStage") {				removeEventListener("addedToStage",callLaterDispatcher);				// now we can listen for render event:				stage.addEventListener(Event.RENDER,callLaterDispatcher,false,0,true);				stage.invalidate();								return;			} else {				event.target.removeEventListener(Event.RENDER,callLaterDispatcher);				if (stage == null) {					// received render, but the stage is not available, so we will listen for addedToStage again:					addEventListener("addedToStage",callLaterDispatcher,false,0,true);					return;				}			}			draw();		}		protected function getSkinInstance(skin:Object):Sprite {			var classDef:Object = null;			// GDS: might remove this, but could be pretty handy for drawing a skin dynamically and attaching it:			if (skin is Class) { return (new skin()) as Sprite; }			else if (skin is Sprite) { return skin as Sprite; }						try {				classDef = loaderInfo.applicationDomain.getDefinition(skin as String) as Object;			} catch(err:Error) {				try {					classDef = getDefinitionByName(skin.toString());				} catch (e:Error) {					// Nothing				}			}						if (classDef == null) {				// GDS: this might be handy as an error:				//trace("skinning class not found! "+p_skin);				return null;			}			return (new classDef()) as Sprite;		}		// the object that controls this component		protected var $owner:Object;		public function set owner(p_owner:Object):void{			$owner = p_owner;					}		public function get owner():Object{			return $owner;		}		public function bringToFront():void{			if(parent != null) {				parent.swapChildren(this,parent.getChildAt(parent.numChildren-1))			}		}		public function sendToBack():void{			if(parent != null) {				parent.swapChildren(this,parent.getChildAt(0))			}		}		/*		protected var $focusEnabled:Boolean=true;		public function set focusEnabled(p_focusEnabled:Boolean):void{			$focusEnabled = p_focusEnabled;					}		public function get focusEnabled():Boolean{			return $focusEnabled;		}		protected var $mouseFocusEnabled:Boolean=true;		public function set mouseFocusEnabled(p_mouseFocusEnabled:Boolean):void{			$mouseFocusEnabled = p_mouseFocusEnabled;					}		public function get mouseFocusEnabled():Boolean{			return $mouseFocusEnabled;		}		public function setFocus(): void {					}		public function drawFocus(draw:Boolean):void {					}		*/	}}